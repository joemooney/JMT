// This file is @generated by prost-build.
/// A 2D point
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct Point {
    #[prost(float, tag = "1")]
    pub x: f32,
    #[prost(float, tag = "2")]
    pub y: f32,
}
/// A rectangle defined by two corners
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct Rect {
    #[prost(float, tag = "1")]
    pub x1: f32,
    #[prost(float, tag = "2")]
    pub y1: f32,
    #[prost(float, tag = "3")]
    pub x2: f32,
    #[prost(float, tag = "4")]
    pub y2: f32,
}
/// RGBA color
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct Color {
    #[prost(uint32, tag = "1")]
    pub r: u32,
    #[prost(uint32, tag = "2")]
    pub g: u32,
    #[prost(uint32, tag = "3")]
    pub b: u32,
    #[prost(uint32, tag = "4")]
    pub a: u32,
}
/// A region within a composite state
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Region {
    #[prost(string, tag = "1")]
    pub id: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub name: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "3")]
    pub bounds: ::core::option::Option<Rect>,
    #[prost(string, repeated, tag = "4")]
    pub child_node_ids: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(bool, tag = "5")]
    pub is_horizontal: bool,
}
/// A state node
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct StateNode {
    #[prost(string, tag = "1")]
    pub id: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub name: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "3")]
    pub bounds: ::core::option::Option<Rect>,
    #[prost(message, optional, tag = "4")]
    pub fill_color: ::core::option::Option<Color>,
    #[prost(string, optional, tag = "5")]
    pub parent_region_id: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, tag = "6")]
    pub entry_activity: ::prost::alloc::string::String,
    #[prost(string, tag = "7")]
    pub exit_activity: ::prost::alloc::string::String,
    #[prost(string, tag = "8")]
    pub do_activity: ::prost::alloc::string::String,
    #[prost(message, repeated, tag = "9")]
    pub regions: ::prost::alloc::vec::Vec<Region>,
}
/// A pseudo-state node
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PseudoStateNode {
    #[prost(string, tag = "1")]
    pub id: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub name: ::prost::alloc::string::String,
    #[prost(enumeration = "NodeType", tag = "3")]
    pub kind: i32,
    #[prost(message, optional, tag = "4")]
    pub bounds: ::core::option::Option<Rect>,
    #[prost(message, optional, tag = "5")]
    pub fill_color: ::core::option::Option<Color>,
    #[prost(string, optional, tag = "6")]
    pub parent_region_id: ::core::option::Option<::prost::alloc::string::String>,
}
/// A node (either state or pseudo-state)
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Node {
    #[prost(oneof = "node::Node", tags = "1, 2")]
    pub node: ::core::option::Option<node::Node>,
}
/// Nested message and enum types in `Node`.
pub mod node {
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Node {
        #[prost(message, tag = "1")]
        State(super::StateNode),
        #[prost(message, tag = "2")]
        Pseudo(super::PseudoStateNode),
    }
}
/// A line segment
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct LineSegment {
    #[prost(message, optional, tag = "1")]
    pub start: ::core::option::Option<Point>,
    #[prost(message, optional, tag = "2")]
    pub end: ::core::option::Option<Point>,
}
/// A connection (transition) between nodes
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Connection {
    #[prost(string, tag = "1")]
    pub id: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub name: ::prost::alloc::string::String,
    #[prost(string, tag = "3")]
    pub source_id: ::prost::alloc::string::String,
    #[prost(string, tag = "4")]
    pub target_id: ::prost::alloc::string::String,
    #[prost(enumeration = "Side", tag = "5")]
    pub source_side: i32,
    #[prost(enumeration = "Side", tag = "6")]
    pub target_side: i32,
    #[prost(float, tag = "7")]
    pub source_offset: f32,
    #[prost(float, tag = "8")]
    pub target_offset: f32,
    #[prost(string, tag = "9")]
    pub event: ::prost::alloc::string::String,
    #[prost(string, tag = "10")]
    pub guard: ::prost::alloc::string::String,
    #[prost(string, tag = "11")]
    pub action: ::prost::alloc::string::String,
}
/// Diagram settings
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DiagramSettings {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    #[prost(string, optional, tag = "2")]
    pub file_path: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(message, optional, tag = "3")]
    pub state_color: ::core::option::Option<Color>,
    #[prost(float, tag = "4")]
    pub corner_rounding: f32,
    #[prost(float, tag = "5")]
    pub stub_length: f32,
    #[prost(float, tag = "6")]
    pub arrow_width: f32,
    #[prost(float, tag = "7")]
    pub arrow_height: f32,
    #[prost(float, tag = "8")]
    pub corner_size: f32,
    #[prost(float, tag = "9")]
    pub pseudo_corner_size: f32,
    #[prost(float, tag = "10")]
    pub default_state_width: f32,
    #[prost(float, tag = "11")]
    pub default_state_height: f32,
    #[prost(float, tag = "12")]
    pub default_pseudo_size: f32,
}
/// A complete diagram
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Diagram {
    #[prost(string, tag = "1")]
    pub id: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "2")]
    pub settings: ::core::option::Option<DiagramSettings>,
    #[prost(message, optional, tag = "3")]
    pub root_state: ::core::option::Option<StateNode>,
    #[prost(message, repeated, tag = "4")]
    pub nodes: ::prost::alloc::vec::Vec<Node>,
    #[prost(message, repeated, tag = "5")]
    pub connections: ::prost::alloc::vec::Vec<Connection>,
}
/// Types of nodes
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum NodeType {
    State = 0,
    Initial = 1,
    Final = 2,
    Choice = 3,
    Fork = 4,
    Join = 5,
    Junction = 6,
}
impl NodeType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::State => "STATE",
            Self::Initial => "INITIAL",
            Self::Final => "FINAL",
            Self::Choice => "CHOICE",
            Self::Fork => "FORK",
            Self::Join => "JOIN",
            Self::Junction => "JUNCTION",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "STATE" => Some(Self::State),
            "INITIAL" => Some(Self::Initial),
            "FINAL" => Some(Self::Final),
            "CHOICE" => Some(Self::Choice),
            "FORK" => Some(Self::Fork),
            "JOIN" => Some(Self::Join),
            "JUNCTION" => Some(Self::Junction),
            _ => None,
        }
    }
}
/// Connection side
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum Side {
    None = 0,
    Top = 1,
    Bottom = 2,
    Left = 3,
    Right = 4,
}
impl Side {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::None => "SIDE_NONE",
            Self::Top => "TOP",
            Self::Bottom => "BOTTOM",
            Self::Left => "LEFT",
            Self::Right => "RIGHT",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "SIDE_NONE" => Some(Self::None),
            "TOP" => Some(Self::Top),
            "BOTTOM" => Some(Self::Bottom),
            "LEFT" => Some(Self::Left),
            "RIGHT" => Some(Self::Right),
            _ => None,
        }
    }
}
/// Request to create a new diagram
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct NewDiagramRequest {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
/// Response with new diagram
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct NewDiagramResponse {
    #[prost(message, optional, tag = "1")]
    pub diagram: ::core::option::Option<Diagram>,
}
/// Request to open a diagram from file
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct OpenDiagramRequest {
    #[prost(string, tag = "1")]
    pub path: ::prost::alloc::string::String,
}
/// Response with opened diagram or error
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct OpenDiagramResponse {
    #[prost(oneof = "open_diagram_response::Result", tags = "1, 2")]
    pub result: ::core::option::Option<open_diagram_response::Result>,
}
/// Nested message and enum types in `OpenDiagramResponse`.
pub mod open_diagram_response {
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Result {
        #[prost(message, tag = "1")]
        Diagram(super::Diagram),
        #[prost(string, tag = "2")]
        Error(::prost::alloc::string::String),
    }
}
/// Request to save a diagram
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SaveDiagramRequest {
    #[prost(message, optional, tag = "1")]
    pub diagram: ::core::option::Option<Diagram>,
    /// If empty, use diagram's existing path
    #[prost(string, optional, tag = "2")]
    pub path: ::core::option::Option<::prost::alloc::string::String>,
}
/// Response from save operation
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SaveDiagramResponse {
    #[prost(bool, tag = "1")]
    pub success: bool,
    #[prost(string, optional, tag = "2")]
    pub error: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "3")]
    pub saved_path: ::core::option::Option<::prost::alloc::string::String>,
}
/// Request to list files in a directory
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListFilesRequest {
    #[prost(string, tag = "1")]
    pub directory: ::prost::alloc::string::String,
    /// e.g., ".json"
    #[prost(string, tag = "2")]
    pub extension_filter: ::prost::alloc::string::String,
}
/// File information
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct FileInfo {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub path: ::prost::alloc::string::String,
    #[prost(int64, tag = "3")]
    pub modified_time: i64,
}
/// Response with list of files
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListFilesResponse {
    #[prost(message, repeated, tag = "1")]
    pub files: ::prost::alloc::vec::Vec<FileInfo>,
}
/// Request for default project path
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct GetProjectPathRequest {}
/// Response with project path
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetProjectPathResponse {
    #[prost(string, tag = "1")]
    pub path: ::prost::alloc::string::String,
}
/// Generic command envelope (for WebSocket transport)
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Command {
    #[prost(uint64, tag = "1")]
    pub request_id: u64,
    #[prost(oneof = "command::Command", tags = "2, 3, 4, 5, 6")]
    pub command: ::core::option::Option<command::Command>,
}
/// Nested message and enum types in `Command`.
pub mod command {
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Command {
        #[prost(message, tag = "2")]
        NewDiagram(super::NewDiagramRequest),
        #[prost(message, tag = "3")]
        OpenDiagram(super::OpenDiagramRequest),
        #[prost(message, tag = "4")]
        SaveDiagram(super::SaveDiagramRequest),
        #[prost(message, tag = "5")]
        ListFiles(super::ListFilesRequest),
        #[prost(message, tag = "6")]
        GetProjectPath(super::GetProjectPathRequest),
    }
}
/// Generic response envelope (for WebSocket transport)
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Response {
    #[prost(uint64, tag = "1")]
    pub request_id: u64,
    #[prost(oneof = "response::Response", tags = "2, 3, 4, 5, 6, 7")]
    pub response: ::core::option::Option<response::Response>,
}
/// Nested message and enum types in `Response`.
pub mod response {
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Response {
        #[prost(message, tag = "2")]
        NewDiagram(super::NewDiagramResponse),
        #[prost(message, tag = "3")]
        OpenDiagram(super::OpenDiagramResponse),
        #[prost(message, tag = "4")]
        SaveDiagram(super::SaveDiagramResponse),
        #[prost(message, tag = "5")]
        ListFiles(super::ListFilesResponse),
        #[prost(message, tag = "6")]
        GetProjectPath(super::GetProjectPathResponse),
        #[prost(string, tag = "7")]
        Error(::prost::alloc::string::String),
    }
}
